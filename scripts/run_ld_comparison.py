"""Simulate data and compare phlash fits with and without the LD term.

The script runs a small stdpopsim simulation, fits phlash twice (with and
without LD enabled), and saves summary statistics and posterior plots for
visual comparison.
"""

from __future__ import annotations

import argparse
import json
import pathlib
from typing import Iterable

import jax
import matplotlib
import numpy as np

matplotlib.use("Agg")
import matplotlib.pyplot as plt

import phlash
from phlash.ld import DEFAULT_BP_BINS, DEFAULT_RECOMB_RATE
from phlash.plot import plot_posterior
from phlash.sim import stdpopsim_dataset
from phlash.size_history import DemographicModel, SizeHistory


def _posterior_grid(dms: Iterable[DemographicModel]) -> tuple[np.ndarray, np.ndarray]:
    """Return time grid and median Ne across posterior samples."""

    t, median, _ = plot_posterior(list(dms), credible_width=None)
    return np.asarray(t), np.asarray(median)


def _median_distance(
    t_ref: np.ndarray,
    median_a: np.ndarray,
    t_other: np.ndarray,
    median_b: np.ndarray,
) -> float:
    """Compute mean relative absolute difference between two median curves."""

    interp_b = np.interp(t_ref, t_other, median_b)
    baseline = np.maximum(median_a, 1e-12)
    return float(np.mean(np.abs(interp_b - median_a) / baseline))


def _summarize(
    label: str,
    dms: Iterable[DemographicModel],
) -> dict:
    t, median, ci = plot_posterior(list(dms), credible_width=0.95)
    return {
        "label": label,
        "t": np.asarray(t).tolist(),
        "median": np.asarray(median).tolist(),
        "ci_lower": np.asarray(ci[0]).tolist(),
        "ci_upper": np.asarray(ci[1]).tolist(),
    }


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--species", default="HomSap", help="stdpopsim species id")
    parser.add_argument("--model", default="Zigzag_1S14", help="stdpopsim model id")
    parser.add_argument(
        "--sample-size",
        type=int,
        default=50,
        help="Diploid sample size per population for simulation.",
    )
    parser.add_argument(
        "--niter", type=int, default=200, help="Number of SVGD iterations for phlash."
    )
    parser.add_argument("--seed", type=int, default=1, help="Random seed for simulation.")
    parser.add_argument(
        "--length-multiplier",
        type=float,
        default=0.05,
        help="Scale contig lengths to keep simulations fast.",
    )
    parser.add_argument(
        "--output-dir",
        type=pathlib.Path,
        default=pathlib.Path("artifacts"),
        help="Directory to store comparison outputs.",
    )
    parser.add_argument(
        "--num-workers", type=int, default=1, help="Parallel workers for data loading."
    )
    parser.add_argument(
        "--ld-recomb-rate",
        type=float,
        default=DEFAULT_RECOMB_RATE,
        help="Recombination rate per bp for LD expectation.",
    )
    args = parser.parse_args()

    args.output_dir.mkdir(parents=True, exist_ok=True)

    populations = {"generic": args.sample_size}
    sim_options = {"length_multiplier": args.length_multiplier}

    print("Simulating stdpopsim dataset...")
    sim = stdpopsim_dataset(
        args.species,
        args.model,
        populations,
        seed=args.seed,
        options=sim_options,
    )

    contigs = list(sim["data"].items())
    if not contigs:
        raise RuntimeError("No contigs generated by stdpopsim simulation")

    test_name, test_contig = contigs[0]
    train_data = [c for name, c in contigs[1:]] or [test_contig]

    base_options = dict(
        truth=sim["truth"],
        niter=args.niter,
        minibatch_size=1,
        num_workers=args.num_workers,
        key=jax.random.PRNGKey(args.seed),
    )

    print("Fitting without LD term...")
    no_ld_dms = phlash.fit(train_data, test_data=test_contig, use_ld=False, **base_options)

    print("Fitting with LD term...")
    ld_dms = phlash.fit(
        train_data,
        test_data=test_contig,
        use_ld=True,
        ld_bp_bins=DEFAULT_BP_BINS,
        ld_recomb_rate=args.ld_recomb_rate,
        **base_options,
    )

    # Plot posterior medians and credible intervals
    fig, ax = plt.subplots()
    plot_posterior(no_ld_dms, ax=ax, label="No LD", credible_width=0.95)
    plot_posterior(ld_dms, ax=ax, label="LD enabled", credible_width=0.95)
    truth: SizeHistory = sim["truth"].eta
    ax.plot(truth.t, truth.Ne, ls="--", color="black", label="Truth")
    ax.set_xscale("log")
    ax.set_yscale("log")
    ax.set_title(f"phlash LD comparison: {args.species} {args.model}")
    ax.legend()
    ax.set_xlabel("Generations")
    ax.set_ylabel("Effective population size")
    fig.tight_layout()

    plot_path = args.output_dir / "phlash_ld_comparison.png"
    fig.savefig(plot_path, dpi=200)
    print(f"Saved plot to {plot_path}")

    # Summaries and distance metrics
    no_ld_summary = _summarize("no_ld", no_ld_dms)
    ld_summary = _summarize("ld_enabled", ld_dms)
    t_ref, med_no_ld = _posterior_grid(no_ld_dms)
    t_ld, med_ld = _posterior_grid(ld_dms)
    rel_diff = _median_distance(t_ref, med_no_ld, t_ld, med_ld)

    summary = {
        "simulation": {
            "species": args.species,
            "model": args.model,
            "populations": populations,
            "length_multiplier": args.length_multiplier,
            "seed": args.seed,
            "test_contig": test_name,
            "train_contigs": [n for n, _ in contigs[1:]] or [test_name],
        },
        "comparisons": {
            "median_relative_difference": rel_diff,
            "ld_recomb_rate": args.ld_recomb_rate,
            "bp_bins": DEFAULT_BP_BINS.tolist(),
        },
        "posteriors": [no_ld_summary, ld_summary],
        "plot": str(plot_path),
    }

    summary_path = args.output_dir / "phlash_ld_comparison.json"
    with summary_path.open("w", encoding="utf-8") as fh:
        json.dump(summary, fh, indent=2)
    print(f"Saved summary to {summary_path}")


if __name__ == "__main__":
    main()
